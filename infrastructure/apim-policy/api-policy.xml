<!--
 A Spike script that deals with translating the SOAP calls:-

 * AddCase
 * GetCase

so that the APIM gateway translates and passes a Restful request downstream to the darts API. Response from the Rest
service are converted back to SOAP

This script relies on a number of pre-configured APIM named values:-

 - aadurl - The AAD token end point
 - clientid - The AAD client id
 - clientsecret - The AAD secret
 - aadkeys - The AAD endpoint to validate tokens
-->
<policies>
  <inbound>
    <base />
    <!-- Sets the variable to be the token from the request -->
    <set-variable name="authToken" value="@(context.Request.Headers.GetValueOrDefault(" Authorization", ""))" />
    <choose>
      <when condition="@(!context.Variables.ContainsKey(" authToken"))">
      <!-- Get the username from the SOAP payload -->
      <set-variable name="userName" value="@{
                XDocument root = context.Request.Body.As<XDocument>();
                string securityNamespace = "http://schemas.xmlsoap.org/ws/2003/06/secext";

      IEnumerable<XElement> username = from el in root.Root.Descendants() where el.Name.LocalName.Equals("Username") & el.Name.NamespaceName.Equals(securityNamespace) select el;

      List<XElement> userNameLst = new List<XElement>();

      string usernameStr = "";
      foreach (XElement p in userNameLst)
      {
      usernameStr = p.Value;
      }

      return usernameStr;
      }" />
      <!-- get the password -->
      <set-variable name="password" value="@{
                XDocument root = context.Request.Body.As<XDocument>();
                string securityNamespace = "http://schemas.xmlsoap.org/ws/2003/06/secext";

      IEnumerable<XElement> password = from el in root.Root.Descendants() where el.Name.LocalName.Equals("Password") & el.Name.Namespace.NamespaceName.Equals(securityNamespace) select el; ;

      string passwwordstr = "";

      foreach (XElement u  in password)
      {
      passwwordstr = u.Value;
      }
      return passwwordstr;
      }" />
      <!-- If the creds are not in the soap payload get them from the authentication header -->
      <choose>
        <when condition="@(((string)context.Variables["username"]).Length==0)">
        <set-variable name="username" value="@{
                        byte[] encodedString = Convert.FromBase64String(context.Request.Headers.GetValueOrDefault("Authorization",":"));

                        string decodedString = System.Text.Encoding.UTF8.GetString(encodedString);

                        int index = decodedString.IndexOf(":");

                        return decodedString.Substring(0,index);
                    }" />
        <set-variable name="password" value="@{
                        byte[] encodedString = Convert.FromBase64String(context.Request.Headers.GetValueOrDefault("Authorization",":"));

                        string decodedString = System.Text.Encoding.UTF8.GetString(encodedString);
                        int index = decodedString.IndexOf(":");

                        return decodedString.Substring(index + 1, (decodedString.Length - index) - 1);
                    }" />
      </when>
    </choose>
    <!--
Get the authentication token for the user
-->
    <send-request mode="new" response-variable-name="authToken" timeout="10" ignore-error="false">
      <set-url>{{aadurl}}</set-url>
      <set-method>POST</set-method>
      <set-header name="Content-Type" exists-action="override">
        <value>application/x-www-form-urlencoded</value>
      </set-header>
      <set-body>@{
        var request =
        "scope:https://hmctsdartsb2csbox.onmicrosoft.com/053d44f9-cd27-463e-a995-bcf835233cf8/Functional.Test&grant_type=password" +
        "&client_id={{clientid}}&client_secret={{clientsecret}}&username=" + context.Variables["userName"] + "&password=" + context.Variables["password"];

        return request.ToString();
        }</set-body>
    </send-request>
  </when>
  <otherwise>
    <!-- Validate using AAD -->
    <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid.">
      <openid-config url="{{aadkeys}}" />
    </validate-jwt>
  </otherwise>
</choose>
  <!-- set the authorisation token -->
<set-header name="Authorization" exists-action="override">
<value>@{
  return "Bearer : " + (string)context.Variables["authToken"];
  }</value>
</set-header>
  <!-- Convert the body into json so we can easily walk it -->
<xml-to-json kind="javascript-friendly" apply="always" consider-accept-header="false" />
  <!-- IMPORTANT: We should ideally scope the following sections per operation. Howebert terraform
      has problems targeting a specific APIM operation, the conditional blocks are thought a workaround to this problem
      in the short term=
  -->
  <!-- Rewrite the url to contain the parameers -->
<choose>
<when condition="@( context.Request.Headers.GetValueOrDefault("SOAPAction","").Equals("getCases"))">
<!-- rewrite the url with the parameters from the soap body -->
<rewrite-uri template="@{
          var request = context.Request.Body.As<JObject>();
          return "/cases?courthouse=" + request["courthouse"] + "&courtroom=" + request["courtroom"] + "&date=" + request["date"];
}" copy-unmatched-params="false" />
<!-- clear soap body of request -->
<set-body />
<set-method>GET</set-method>
</when>
  </choose>
<choose>
<!-- Adapt the SOAP request to the required Resfful payload for adding a case -->
<when condition="@( context.Request.Headers.GetValueOrDefault("SOAPAction", "").Equals("addCase"))">
<!-- IMPORTANT: We need to validate against a schema (as the current gateway implementation does) but by default this policy tag validates against the request body
which is not correct. We need to validate the embedded xml against a schema
<validate-content unspecified-content-type-action="prevent " max-size="102400" size-exceeded-action="ignore" errors-variable-name="addCasesValidation">
<content-type-map any-content-type-value="application/xml" >
</content-type-map>
<content type="content type string" validate-as="xml" schema-id="addCaseSchema" action="prevent " allow-additional-properties="false" />
</validate-content>
-->
<!-- rewrite the body of the request to be restful using liquid templatng-->
<set-body template="liquid">
  {
  "courthouse": "{{context.Request.Envelope.Body.addCase.document.courthouse}}",
  "case_number": "{{context.Request.Envelope.Body.addCase.document.id}}",
  "defendants": [
  {% for defendant in context.Request.Envelope.Body.addCase.Document.defendants %}
  {%- if forloop.length &gt; 0 -%}
  "{{defendant}}"{% unless forloop.last %},{% endunless -%}
  {%- endif -%}
  {% endfor %}
  ],
  "judges": [
  {% for judge in context.Request.Envelope.Body.addCase.Document.judges %}
  {%- if forloop.length &gt; 0 -%}
  "{{judge}}"{% unless forloop.last %},{% endunless -%}
  {%- endif -%}
  {% endfor %}
  ],
  "prosecutors": [
  {% for prosecutor in context.Request.Envelope.Body.addCase.Document.prosecutors %}
  {%- if forloop.length &gt; 0 -%}
  "{{prosecutor}}"{% unless forloop.last %},{% endunless -%}
  {%- endif -%}
  {% endfor %}
  ],
  "defenders": [
  {% for defender in context.Request.Envelope.Body.addCase.Document.defenders %}
  {%- if forloop.length &gt; 0 -%}
  "{{defender}}"{% unless forloop.last %},{% endunless -%}
  {%- endif -%}
  {% endfor %}
  ]
  }

</set-body>
<set-method>POST</set-method>
<rewrite-uri template="/cases" />
</when>
  </choose>
<set-header name="Content-Type" exists-action="override">
<value>application/json</value>
</set-header>
  </inbound>
<backend>
<base />
</backend>
<outbound>
<base />
<!-- Deal with the get cases response -->
<choose>
  <when condition="@( context.Request.Headers.GetValueOrDefault("SOAPAction").Equals("getCases"))">
  <set-header name="Content-Type" exists-action="override">
    <value>text/xml</value>
  </set-header>
  <!-- A liquid templating fragment in order to substitute values into the response xml-->
  <set-body template="liquid">
    {%     assign dates = context.Request.Envelope.Body.getCases.date | Split: "-"          %}
    {%     assign courthouse = context.Request.Envelope.Body.getCases.courthouse        %}
    {%     assign courtroom = context.Request.Envelope.Body.getCases.courtroom        %}


    <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"><SOAP-ENV:Header /><SOAP-ENV:Body><ns3:getCasesResponse xmlns:ns3="http://com.synapps.mojdarts.service.com"><return><cases D="{{dates[0]}}" M="{{dates[1]}}" Y="{{dates[2]}}" courthouse="{{courthouse}}" courtroom="{{courtroom}}">
      {% for case in body.cases %}
      <case><case_number>{{ case.caseNumber }}</case_number><scheduled_start>{{ case.scheduledStart }}</scheduled_start><defendants>
        {% for defendant in case.defendants %}
        <defendant>{{defendant}}</defendant>
        {% endfor %}
      </defendants><judges>
        {% for judge in case.judges %}
        <judge>{{judge}}</judge>
        {% endfor %}
      </judges><prosecutors>
        {% for prosecutor in case.prosecutors %}
        <prosecutor>{{prosecutor}}</prosecutor>
        {% endfor %}
      </prosecutors><defenders>
        {% for defender in case.defenders %}
        <defender>{{defender}}</defender>
        {% endfor %}
      </defenders></case>
      {% endfor %}
    </cases></return></ns3:getCasesResponse></SOAP-ENV:Body></SOAP-ENV:Envelope></set-body>
</when>
</choose>
  <!-- Deal with the add cases SOAP response -->
<choose>
<when condition="@(context.Request.Headers.GetValueOrDefault("SOAPAction").Equals("addCase"))">
<set-body template="liquid">
  <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/">
    <SOAP-ENV:Header />
    <SOAP-ENV:Body>
      <ns3:addCaseResponse xmlns:ns3="http://com.synapps.mojdarts.service.com">
        <return>
          <code>{{body.code}}</code>
          <message>{{body.message}}</message>
        </return>
      </ns3:addCaseResponse>
    </SOAP-ENV:Body>
  </SOAP-ENV:Envelope>
</set-body>
</when>
  </choose>
  </outbound>
<on-error>
<!-- A general error response coming from the darts api-->
<base />
<set-body template="liquid">
  <SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsi="http://www.w3.org/1999/XMLSchema-instance" xmlns:xsd="http://www.w3.org/1999/XMLSchema">
    <SOAP-ENV:Body>
      <SOAP-ENV:Fault>
        <faultcode xsi:type="xsd:string">{{body.status}}</faultcode>
        <faultstring xsi:type="xsd:string">
          {{body.detail}}
        </faultstring>
      </SOAP-ENV:Fault>
    </SOAP-ENV:Body>
  </SOAP-ENV:Envelope>
</set-body>
</on-error>
  </policies>
